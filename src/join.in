#! /usr/bin/env bash

# Copyright (C) 2024 Mattéo Rossillol‑‑Laruelle <beatussum@protonmail.com>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.


set -o pipefail

readonly JOIN_SOURCE="${BASH_SOURCE[0]}"
readonly JOIN_VERSION=@VERSION@

declare -A JOIN_OPTIONS=( [lines]=17 )

########
# CORE #
########

die() {
	local msg="$*"

	[[ -z "${msg}" ]] && msg="(none)"

	cat >&2 <<-EOF

	===============================================================================
	Fatal error with the following message:
	  -> ${msg}

	${JOIN_SOURCE} at line ${BASH_LINENO[0]}:

	$(gawk "NR == ${BASH_LINENO[0]} { print }" "${JOIN_SOURCE}")

	===============================================================================

	EOF

	exit 1
}

is_number() {
	local n="$1"

	[[ "${n}" =~ ^[-+]?[0-9]+$ ]]
}

###########
# HELPERS #
###########

accumulate() {
	local entry="$1"

	local ret
	local files

	files="$(list "${entry}")" || die
	mapfile -t files < <(echo -n "${files}")

	for file in "${files[@]}"; do
		ret+="$(get_content_of "${file}")" || die
		ret+=$'\n\n'
	done

	echo "${ret}"
}

get_content_of() {
	local file="$1"

	# shellcheck disable=SC2086
	# `JOIN_OPTIONS[lines]` is a number.
	tail +${JOIN_OPTIONS[lines]} < "${file}" || die
}

list() {
	local entry="$1"

	local ret

	if [[ -d "${entry}" ]]; then
		ret="$(find "${entry}" -maxdepth 1 -mindepth 1 -type f | sort)" || die
		mapfile -t ret < <(echo -n "${ret}")
	elif [[ -f "${entry}" || -p "${entry}" ]]; then
		ret=( "${entry}" )
	else
		die "\`${entry}\` does not exist"
	fi

	if [[ ${#ret} -ne 0 ]]; then
		IFS=$'\n'
		echo "${ret[*]}"
		unset IFS
	fi
}

###########
# ACTIONS #
###########

copyright() {
	cat <<-EOF
	Copyright (C) 2024 Mattéo Rossillol‑‑Laruelle <beatussum@protonmail.com>

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
	EOF
}

join() (
	local -n ref_patterns="$1"
	local -n ref_inputs="$2"

	for pattern in "${!ref_patterns[@]}"; do
		local entry="${ref_patterns["${pattern}"]}"

		local content

		if [[ "${entry}" =~ ^\"(.*)\"$ ]]; then
			content="${BASH_REMATCH[1]}"
		else
			[[ "${content}" = - ]] && content=/dev/stdin

			content="$(accumulate "${entry}")" || die
			content="${content//&/\\&}"
		fi

		export "${pattern}"="${content}"
	done

	cat <<-"EOF" | gawk -f - -- "${ref_inputs[@]}" || die
	BEGIN { FPAT = "@[A-Z]+@" }

	NF == 0 { print }

	NF != 0 {
		while (NF != 0) {
			key = substr($1, 2, length($1) - 2)
			sub($1, ENVIRON[key])
		}

		print
	}
	EOF
)

usage() {
	cat <<-EOF
	Usage: ${JOIN_SOURCE} [options...] [--] [patterns...] [--] [inputs...]

	Options:
	  -c,--copyright    Print copyright information.
	  -h,--help         Print this message.
	  -l,--lines NUM    Set the number of lines to be deleted at the beginning of
	                    each entry to NUM.
	  -v,--version      Print version information.

	Patterns are defined with the following syntax:
	  1. @<PATTERN>@=<file>
	  2. @<PATTERN>@=<directory>
	  3. @<PATTERN>@="<string>"

	PATTERN must be uppercase.

	With the syntax (1), all the entries @PATTERN@ in inputs will be replaced by the
	content of file.

	With the syntax (2), all the entries @PATTERN@ in inputs will be replaced by the
	content of all the files in directory.

	With the syntax (3), all the entries @PATTERN@ in inputs will be replaced by
	string. As the shell will probably interpreted double quotes, the latter should
	be escaped, e.g. @FOO@='"bar"'.

	${JOIN_SOURCE} Copyright (C) 2024 Mattéo Rossillol‑‑Laruelle <beatussum@protonmail.com>
	This program comes with ABSOLUTELY NO WARRANTY; for details type \`${JOIN_SOURCE} --copyright'.
	This is free software, and you are welcome to redistribute it
	under certain conditions; type \`${JOIN_SOURCE} --copyright' for details.
	EOF
}

version() {
	echo "${JOIN_SOURCE} version ${JOIN_VERSION}"
}

#################
# MAIN FUNCTION #
#################

main() {
	while [[ $# -ne 0 ]]; do
		case "$1" in
			-c|--copyright)
				copyright
				exit

				;;

			-h|--help)
				usage
				exit

				;;

			-l|--lines)
				if is_number "$2"; then
					JOIN_OPTIONS[lines]=$2
				else
					die "\`$2\` is not a number"
				fi

				shift

				;;

			-v|--version)
				version
				exit

				;;

			--)
				shift
				break

				;;

			-*)
				usage >&2
				die "\`$1\` is not a correct option"

				;;

			*) break ;;
		esac

		shift
	done

	local -A patterns

	while [[ $# -ne 0 ]]; do
		if [[ "$1" =~ ([A-Z]+)=(.*) ]]; then
			local pattern="${BASH_REMATCH[1]}"
			local entry="${BASH_REMATCH[2]}"

			# shellcheck disable=SC2034
			# `patterns` is used by reference.
			patterns["${pattern}"]="${entry}"
		elif [[ "$1" = -- ]]; then
			shift
			break
		else
			break
		fi

		shift
	done

	# shellcheck disable=SC2034
	# `inputs` is used by reference.
	local inputs=( "$@" )

	join patterns inputs || die
}

main "$@"
